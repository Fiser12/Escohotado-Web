/* tslint:disable */
/* eslint-disable */
/**
 * This file was automatically generated by Payload.
 * DO NOT MODIFY IT BY HAND. Instead, modify your source Payload config,
 * and re-run `payload generate:db-schema` to regenerate this file.
 */

import {
  pgTable,
  index,
  uniqueIndex,
  foreignKey,
  integer,
  varchar,
  timestamp,
  jsonb,
  uuid,
  boolean,
  numeric,
  serial,
  type AnyPgColumn,
  pgEnum,
} from '@payloadcms/db-postgres/drizzle/pg-core'
import { sql, relations } from '@payloadcms/db-postgres/drizzle'
export const enum_prices_type = pgEnum('enum_prices_type', ['one_time', 'recurring'])
export const enum_prices_interval = pgEnum('enum_prices_interval', ['day', 'week', 'month', 'year'])
export const enum_products_type = pgEnum('enum_products_type', ['good', 'service'])
export const enum_subscriptions_status = pgEnum('enum_subscriptions_status', [
  'trialing',
  'active',
  'canceled',
  'incomplete',
  'incomplete_expired',
  'past_due',
  'unpaid',
  'paused',
])
export const enum_book_ediciones_variant = pgEnum('enum_book_ediciones_variant', [
  'audiobook',
  'ebook',
  'book',
])
export const enum_book_ediciones_language = pgEnum('enum_book_ediciones_language', ['es', 'en'])

export const users_accounts = pgTable(
  'users_accounts',
  {
    _order: integer('_order').notNull(),
    _parentID: varchar('_parent_id').notNull(),
    id: varchar('id').primaryKey(),
    provider: varchar('provider').notNull(),
    providerAccountId: varchar('provider_account_id').notNull(),
    type: varchar('type').notNull(),
  },
  (columns) => ({
    _orderIdx: index('users_accounts_order_idx').on(columns._order),
    _parentIDIdx: index('users_accounts_parent_id_idx').on(columns._parentID),
    _parentIDFk: foreignKey({
      columns: [columns['_parentID']],
      foreignColumns: [users.id],
      name: 'users_accounts_parent_id_fk',
    }).onDelete('cascade'),
  }),
)

export const users_sessions = pgTable(
  'users_sessions',
  {
    _order: integer('_order').notNull(),
    _parentID: varchar('_parent_id').notNull(),
    id: varchar('id').primaryKey(),
    sessionToken: varchar('session_token').notNull(),
    expires: timestamp('expires', { mode: 'string', withTimezone: true, precision: 3 }).notNull(),
  },
  (columns) => ({
    _orderIdx: index('users_sessions_order_idx').on(columns._order),
    _parentIDIdx: index('users_sessions_parent_id_idx').on(columns._parentID),
    _parentIDFk: foreignKey({
      columns: [columns['_parentID']],
      foreignColumns: [users.id],
      name: 'users_sessions_parent_id_fk',
    }).onDelete('cascade'),
  }),
)

export const users_verification_tokens = pgTable(
  'users_verification_tokens',
  {
    _order: integer('_order').notNull(),
    _parentID: varchar('_parent_id').notNull(),
    id: varchar('id').primaryKey(),
    token: varchar('token').notNull(),
    expires: timestamp('expires', { mode: 'string', withTimezone: true, precision: 3 }).notNull(),
  },
  (columns) => ({
    _orderIdx: index('users_verification_tokens_order_idx').on(columns._order),
    _parentIDIdx: index('users_verification_tokens_parent_id_idx').on(columns._parentID),
    _parentIDFk: foreignKey({
      columns: [columns['_parentID']],
      foreignColumns: [users.id],
      name: 'users_verification_tokens_parent_id_fk',
    }).onDelete('cascade'),
  }),
)

export const users = pgTable(
  'users',
  {
    id: varchar('id').primaryKey(),
    name: varchar('name'),
    roles: jsonb('roles'),
    stripeCustomerId: varchar('stripe_customer_id'),
    email: varchar('email').notNull(),
    image: varchar('image'),
    emailVerified: timestamp('email_verified', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    }),
    updatedAt: timestamp('updated_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    users_updated_at_idx: index('users_updated_at_idx').on(columns.updatedAt),
    users_created_at_idx: index('users_created_at_idx').on(columns.createdAt),
  }),
)

export const prices = pgTable(
  'prices',
  {
    id: uuid('id').defaultRandom().primaryKey(),
    stripeID: varchar('stripe_i_d').notNull(),
    stripeProductId: varchar('stripe_product_id').notNull(),
    active: boolean('active').notNull().default(false),
    description: varchar('description'),
    unitAmount: numeric('unit_amount').notNull(),
    currency: varchar('currency').notNull(),
    type: enum_prices_type('type').notNull(),
    interval: enum_prices_interval('interval'),
    intervalCount: numeric('interval_count'),
    trialPeriodDays: numeric('trial_period_days'),
    metadata: jsonb('metadata'),
    updatedAt: timestamp('updated_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    prices_updated_at_idx: index('prices_updated_at_idx').on(columns.updatedAt),
    prices_created_at_idx: index('prices_created_at_idx').on(columns.createdAt),
  }),
)

export const products_images = pgTable(
  'products_images',
  {
    _order: integer('_order').notNull(),
    _parentID: uuid('_parent_id').notNull(),
    id: varchar('id').primaryKey(),
    url: varchar('url'),
  },
  (columns) => ({
    _orderIdx: index('products_images_order_idx').on(columns._order),
    _parentIDIdx: index('products_images_parent_id_idx').on(columns._parentID),
    _parentIDFk: foreignKey({
      columns: [columns['_parentID']],
      foreignColumns: [products.id],
      name: 'products_images_parent_id_fk',
    }).onDelete('cascade'),
  }),
)

export const products_features = pgTable(
  'products_features',
  {
    _order: integer('_order').notNull(),
    _parentID: uuid('_parent_id').notNull(),
    id: varchar('id').primaryKey(),
    title: varchar('title'),
  },
  (columns) => ({
    _orderIdx: index('products_features_order_idx').on(columns._order),
    _parentIDIdx: index('products_features_parent_id_idx').on(columns._parentID),
    _parentIDFk: foreignKey({
      columns: [columns['_parentID']],
      foreignColumns: [products.id],
      name: 'products_features_parent_id_fk',
    }).onDelete('cascade'),
  }),
)

export const products = pgTable(
  'products',
  {
    id: uuid('id').defaultRandom().primaryKey(),
    stripeID: varchar('stripe_i_d').notNull(),
    type: enum_products_type('type'),
    active: boolean('active').notNull().default(false),
    name: varchar('name').notNull(),
    description: varchar('description'),
    metadata: jsonb('metadata'),
    permissions_seeds: varchar('permissions_seeds').default(''),
    updatedAt: timestamp('updated_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    products_updated_at_idx: index('products_updated_at_idx').on(columns.updatedAt),
    products_created_at_idx: index('products_created_at_idx').on(columns.createdAt),
  }),
)

export const products_rels = pgTable(
  'products_rels',
  {
    id: serial('id').primaryKey(),
    order: integer('order'),
    parent: uuid('parent_id').notNull(),
    path: varchar('path').notNull(),
    pricesID: uuid('prices_id'),
    permissionID: varchar('permission_id'),
  },
  (columns) => ({
    order: index('products_rels_order_idx').on(columns.order),
    parentIdx: index('products_rels_parent_idx').on(columns.parent),
    pathIdx: index('products_rels_path_idx').on(columns.path),
    products_rels_prices_id_idx: index('products_rels_prices_id_idx').on(columns.pricesID),
    products_rels_permission_id_idx: index('products_rels_permission_id_idx').on(
      columns.permissionID,
    ),
    parentFk: foreignKey({
      columns: [columns['parent']],
      foreignColumns: [products.id],
      name: 'products_rels_parent_fk',
    }).onDelete('cascade'),
    pricesIdFk: foreignKey({
      columns: [columns['pricesID']],
      foreignColumns: [prices.id],
      name: 'products_rels_prices_fk',
    }).onDelete('cascade'),
    permissionIdFk: foreignKey({
      columns: [columns['permissionID']],
      foreignColumns: [permission.id],
      name: 'products_rels_permission_fk',
    }).onDelete('cascade'),
  }),
)

export const subscriptions = pgTable(
  'subscriptions',
  {
    id: uuid('id').defaultRandom().primaryKey(),
    user: varchar('user_id')
      .notNull()
      .references(() => users.id, {
        onDelete: 'set null',
      }),
    product: uuid('product_id')
      .notNull()
      .references(() => products.id, {
        onDelete: 'set null',
      }),
    status: enum_subscriptions_status('status').notNull(),
    created: timestamp('created', { mode: 'string', withTimezone: true, precision: 3 }),
    currentPeriodStart: timestamp('current_period_start', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    }),
    currentPeriodEnd: timestamp('current_period_end', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    }),
    endedAt: timestamp('ended_at', { mode: 'string', withTimezone: true, precision: 3 }),
    cancelAt: timestamp('cancel_at', { mode: 'string', withTimezone: true, precision: 3 }),
    canceledAt: timestamp('canceled_at', { mode: 'string', withTimezone: true, precision: 3 }),
    cancelAtPeriodEnd: boolean('cancel_at_period_end'),
    trialStart: timestamp('trial_start', { mode: 'string', withTimezone: true, precision: 3 }),
    trialEnd: timestamp('trial_end', { mode: 'string', withTimezone: true, precision: 3 }),
    stripeID: varchar('stripe_i_d').notNull(),
    stripePriceID: varchar('stripe_price_i_d').notNull(),
    stripeCustomerId: varchar('stripe_customer_id').notNull(),
    metadata: jsonb('metadata'),
    permissions_seeds: varchar('permissions_seeds').default(''),
    updatedAt: timestamp('updated_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    subscriptions_user_idx: index('subscriptions_user_idx').on(columns.user),
    subscriptions_product_idx: index('subscriptions_product_idx').on(columns.product),
    subscriptions_updated_at_idx: index('subscriptions_updated_at_idx').on(columns.updatedAt),
    subscriptions_created_at_idx: index('subscriptions_created_at_idx').on(columns.createdAt),
  }),
)

export const media = pgTable(
  'media',
  {
    id: uuid('id').defaultRandom().primaryKey(),
    title: varchar('title'),
    rawContent: varchar('raw_content'),
    prefix: varchar('prefix').default('media'),
    updatedAt: timestamp('updated_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
    url: varchar('url'),
    thumbnailURL: varchar('thumbnail_u_r_l'),
    filename: varchar('filename'),
    mimeType: varchar('mime_type'),
    filesize: numeric('filesize'),
    width: numeric('width'),
    height: numeric('height'),
    focalX: numeric('focal_x'),
    focalY: numeric('focal_y'),
    sizes_thumbnail_url: varchar('sizes_thumbnail_url'),
    sizes_thumbnail_width: numeric('sizes_thumbnail_width'),
    sizes_thumbnail_height: numeric('sizes_thumbnail_height'),
    sizes_thumbnail_mimeType: varchar('sizes_thumbnail_mime_type'),
    sizes_thumbnail_filesize: numeric('sizes_thumbnail_filesize'),
    sizes_thumbnail_filename: varchar('sizes_thumbnail_filename'),
  },
  (columns) => ({
    media_updated_at_idx: index('media_updated_at_idx').on(columns.updatedAt),
    media_created_at_idx: index('media_created_at_idx').on(columns.createdAt),
    media_filename_idx: uniqueIndex('media_filename_idx').on(columns.filename),
    media_sizes_thumbnail_sizes_thumbnail_filename_idx: index(
      'media_sizes_thumbnail_sizes_thumbnail_filename_idx',
    ).on(columns.sizes_thumbnail_filename),
  }),
)

export const taxonomy = pgTable(
  'taxonomy',
  {
    id: varchar('id').primaryKey(),
    selectable: boolean('selectable').default(true),
    slug: varchar('slug').notNull(),
    singular_name: varchar('singular_name').notNull(),
    plural_name: varchar('plural_name'),
    seed: varchar('seed'),
    parent: varchar('parent_id').references((): AnyPgColumn => taxonomy.id, {
      onDelete: 'set null',
    }),
    updatedAt: timestamp('updated_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    taxonomy_slug_idx: uniqueIndex('taxonomy_slug_idx').on(columns.slug),
    taxonomy_parent_idx: index('taxonomy_parent_idx').on(columns.parent),
    taxonomy_updated_at_idx: index('taxonomy_updated_at_idx').on(columns.updatedAt),
    taxonomy_created_at_idx: index('taxonomy_created_at_idx').on(columns.createdAt),
  }),
)

export const article_pdf = pgTable(
  'article_pdf',
  {
    id: uuid('id').defaultRandom().primaryKey(),
    permissions_seeds: varchar('permissions_seeds').default(''),
    cover: uuid('cover_id')
      .notNull()
      .references(() => media.id, {
        onDelete: 'set null',
      }),
    title: varchar('title').notNull(),
    description: varchar('description'),
    publishedAt: timestamp('published_at', { mode: 'string', withTimezone: true, precision: 3 }),
    seeds: varchar('seeds').default(''),
    forum_post_id: varchar('forum_post_id'),
    last_forum_sync: timestamp('last_forum_sync', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    }),
    last_forum_posts: jsonb('last_forum_posts'),
    prefix: varchar('prefix').default('article_pdf'),
    updatedAt: timestamp('updated_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
    url: varchar('url'),
    thumbnailURL: varchar('thumbnail_u_r_l'),
    filename: varchar('filename'),
    mimeType: varchar('mime_type'),
    filesize: numeric('filesize'),
    width: numeric('width'),
    height: numeric('height'),
    focalX: numeric('focal_x'),
    focalY: numeric('focal_y'),
  },
  (columns) => ({
    article_pdf_cover_idx: index('article_pdf_cover_idx').on(columns.cover),
    article_pdf_updated_at_idx: index('article_pdf_updated_at_idx').on(columns.updatedAt),
    article_pdf_created_at_idx: index('article_pdf_created_at_idx').on(columns.createdAt),
    article_pdf_filename_idx: uniqueIndex('article_pdf_filename_idx').on(columns.filename),
  }),
)

export const article_pdf_rels = pgTable(
  'article_pdf_rels',
  {
    id: serial('id').primaryKey(),
    order: integer('order'),
    parent: uuid('parent_id').notNull(),
    path: varchar('path').notNull(),
    permissionID: varchar('permission_id'),
    taxonomyID: varchar('taxonomy_id'),
  },
  (columns) => ({
    order: index('article_pdf_rels_order_idx').on(columns.order),
    parentIdx: index('article_pdf_rels_parent_idx').on(columns.parent),
    pathIdx: index('article_pdf_rels_path_idx').on(columns.path),
    article_pdf_rels_permission_id_idx: index('article_pdf_rels_permission_id_idx').on(
      columns.permissionID,
    ),
    article_pdf_rels_taxonomy_id_idx: index('article_pdf_rels_taxonomy_id_idx').on(
      columns.taxonomyID,
    ),
    parentFk: foreignKey({
      columns: [columns['parent']],
      foreignColumns: [article_pdf.id],
      name: 'article_pdf_rels_parent_fk',
    }).onDelete('cascade'),
    permissionIdFk: foreignKey({
      columns: [columns['permissionID']],
      foreignColumns: [permission.id],
      name: 'article_pdf_rels_permission_fk',
    }).onDelete('cascade'),
    taxonomyIdFk: foreignKey({
      columns: [columns['taxonomyID']],
      foreignColumns: [taxonomy.id],
      name: 'article_pdf_rels_taxonomy_fk',
    }).onDelete('cascade'),
  }),
)

export const article_web = pgTable(
  'article_web',
  {
    id: uuid('id').defaultRandom().primaryKey(),
    permissions_seeds: varchar('permissions_seeds').default(''),
    cover: uuid('cover_id')
      .notNull()
      .references(() => media.id, {
        onDelete: 'set null',
      }),
    title: varchar('title').notNull(),
    description: varchar('description'),
    publishedAt: timestamp('published_at', { mode: 'string', withTimezone: true, precision: 3 }),
    seeds: varchar('seeds').default(''),
    slug: varchar('slug').notNull(),
    content: jsonb('content'),
    content_html: varchar('content_html'),
    forum_post_id: varchar('forum_post_id'),
    last_forum_sync: timestamp('last_forum_sync', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    }),
    last_forum_posts: jsonb('last_forum_posts'),
    updatedAt: timestamp('updated_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    article_web_cover_idx: index('article_web_cover_idx').on(columns.cover),
    article_web_slug_idx: uniqueIndex('article_web_slug_idx').on(columns.slug),
    article_web_updated_at_idx: index('article_web_updated_at_idx').on(columns.updatedAt),
    article_web_created_at_idx: index('article_web_created_at_idx').on(columns.createdAt),
  }),
)

export const article_web_rels = pgTable(
  'article_web_rels',
  {
    id: serial('id').primaryKey(),
    order: integer('order'),
    parent: uuid('parent_id').notNull(),
    path: varchar('path').notNull(),
    permissionID: varchar('permission_id'),
    taxonomyID: varchar('taxonomy_id'),
  },
  (columns) => ({
    order: index('article_web_rels_order_idx').on(columns.order),
    parentIdx: index('article_web_rels_parent_idx').on(columns.parent),
    pathIdx: index('article_web_rels_path_idx').on(columns.path),
    article_web_rels_permission_id_idx: index('article_web_rels_permission_id_idx').on(
      columns.permissionID,
    ),
    article_web_rels_taxonomy_id_idx: index('article_web_rels_taxonomy_id_idx').on(
      columns.taxonomyID,
    ),
    parentFk: foreignKey({
      columns: [columns['parent']],
      foreignColumns: [article_web.id],
      name: 'article_web_rels_parent_fk',
    }).onDelete('cascade'),
    permissionIdFk: foreignKey({
      columns: [columns['permissionID']],
      foreignColumns: [permission.id],
      name: 'article_web_rels_permission_fk',
    }).onDelete('cascade'),
    taxonomyIdFk: foreignKey({
      columns: [columns['taxonomyID']],
      foreignColumns: [taxonomy.id],
      name: 'article_web_rels_taxonomy_fk',
    }).onDelete('cascade'),
  }),
)

export const book_ediciones = pgTable(
  'book_ediciones',
  {
    _order: integer('_order').notNull(),
    _parentID: uuid('_parent_id').notNull(),
    id: varchar('id').primaryKey(),
    link: varchar('link'),
    variant: enum_book_ediciones_variant('variant'),
    language: enum_book_ediciones_language('language'),
  },
  (columns) => ({
    _orderIdx: index('book_ediciones_order_idx').on(columns._order),
    _parentIDIdx: index('book_ediciones_parent_id_idx').on(columns._parentID),
    _parentIDFk: foreignKey({
      columns: [columns['_parentID']],
      foreignColumns: [book.id],
      name: 'book_ediciones_parent_id_fk',
    }).onDelete('cascade'),
  }),
)

export const book = pgTable(
  'book',
  {
    id: uuid('id').defaultRandom().primaryKey(),
    cover: uuid('cover_id')
      .notNull()
      .references(() => media.id, {
        onDelete: 'set null',
      }),
    title: varchar('title').notNull(),
    description: varchar('description'),
    publishedAt: timestamp('published_at', { mode: 'string', withTimezone: true, precision: 3 }),
    seeds: varchar('seeds').default(''),
    content: jsonb('content'),
    content_html: varchar('content_html'),
    slug: varchar('slug').notNull(),
    forum_post_id: varchar('forum_post_id'),
    last_forum_sync: timestamp('last_forum_sync', {
      mode: 'string',
      withTimezone: true,
      precision: 3,
    }),
    last_forum_posts: jsonb('last_forum_posts'),
    updatedAt: timestamp('updated_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    book_cover_idx: index('book_cover_idx').on(columns.cover),
    book_slug_idx: uniqueIndex('book_slug_idx').on(columns.slug),
    book_updated_at_idx: index('book_updated_at_idx').on(columns.updatedAt),
    book_created_at_idx: index('book_created_at_idx').on(columns.createdAt),
  }),
)

export const book_rels = pgTable(
  'book_rels',
  {
    id: serial('id').primaryKey(),
    order: integer('order'),
    parent: uuid('parent_id').notNull(),
    path: varchar('path').notNull(),
    taxonomyID: varchar('taxonomy_id'),
  },
  (columns) => ({
    order: index('book_rels_order_idx').on(columns.order),
    parentIdx: index('book_rels_parent_idx').on(columns.parent),
    pathIdx: index('book_rels_path_idx').on(columns.path),
    book_rels_taxonomy_id_idx: index('book_rels_taxonomy_id_idx').on(columns.taxonomyID),
    parentFk: foreignKey({
      columns: [columns['parent']],
      foreignColumns: [book.id],
      name: 'book_rels_parent_fk',
    }).onDelete('cascade'),
    taxonomyIdFk: foreignKey({
      columns: [columns['taxonomyID']],
      foreignColumns: [taxonomy.id],
      name: 'book_rels_taxonomy_fk',
    }).onDelete('cascade'),
  }),
)

export const video = pgTable(
  'video',
  {
    id: uuid('id').defaultRandom().primaryKey(),
    url: varchar('url').notNull(),
    url_free: varchar('url_free'),
    permissions_seeds: varchar('permissions_seeds').default(''),
    tags: jsonb('tags'),
    thumbnailUrl: varchar('thumbnail_url'),
    title: varchar('title'),
    description: varchar('description'),
    publishedAt: timestamp('published_at', { mode: 'string', withTimezone: true, precision: 3 }),
    updatedAt: timestamp('updated_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    video_url_idx: uniqueIndex('video_url_idx').on(columns.url),
    video_updated_at_idx: index('video_updated_at_idx').on(columns.updatedAt),
    video_created_at_idx: index('video_created_at_idx').on(columns.createdAt),
  }),
)

export const video_rels = pgTable(
  'video_rels',
  {
    id: serial('id').primaryKey(),
    order: integer('order'),
    parent: uuid('parent_id').notNull(),
    path: varchar('path').notNull(),
    permissionID: varchar('permission_id'),
  },
  (columns) => ({
    order: index('video_rels_order_idx').on(columns.order),
    parentIdx: index('video_rels_parent_idx').on(columns.parent),
    pathIdx: index('video_rels_path_idx').on(columns.path),
    video_rels_permission_id_idx: index('video_rels_permission_id_idx').on(columns.permissionID),
    parentFk: foreignKey({
      columns: [columns['parent']],
      foreignColumns: [video.id],
      name: 'video_rels_parent_fk',
    }).onDelete('cascade'),
    permissionIdFk: foreignKey({
      columns: [columns['permissionID']],
      foreignColumns: [permission.id],
      name: 'video_rels_permission_fk',
    }).onDelete('cascade'),
  }),
)

export const permission = pgTable(
  'permission',
  {
    id: varchar('id').primaryKey(),
    slug: varchar('slug').notNull(),
    title: varchar('title').notNull(),
    updatedAt: timestamp('updated_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    permission_slug_idx: uniqueIndex('permission_slug_idx').on(columns.slug),
    permission_updated_at_idx: index('permission_updated_at_idx').on(columns.updatedAt),
    permission_created_at_idx: index('permission_created_at_idx').on(columns.createdAt),
  }),
)

export const search_results = pgTable(
  'search_results',
  {
    id: uuid('id').defaultRandom().primaryKey(),
    title: varchar('title'),
    priority: numeric('priority'),
    tags: varchar('tags'),
    updatedAt: timestamp('updated_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    search_results_updated_at_idx: index('search_results_updated_at_idx').on(columns.updatedAt),
    search_results_created_at_idx: index('search_results_created_at_idx').on(columns.createdAt),
  }),
)

export const search_results_rels = pgTable(
  'search_results_rels',
  {
    id: serial('id').primaryKey(),
    order: integer('order'),
    parent: uuid('parent_id').notNull(),
    path: varchar('path').notNull(),
    videoID: uuid('video_id'),
    article_webID: uuid('article_web_id'),
    article_pdfID: uuid('article_pdf_id'),
    bookID: uuid('book_id'),
  },
  (columns) => ({
    order: index('search_results_rels_order_idx').on(columns.order),
    parentIdx: index('search_results_rels_parent_idx').on(columns.parent),
    pathIdx: index('search_results_rels_path_idx').on(columns.path),
    search_results_rels_video_id_idx: index('search_results_rels_video_id_idx').on(columns.videoID),
    search_results_rels_article_web_id_idx: index('search_results_rels_article_web_id_idx').on(
      columns.article_webID,
    ),
    search_results_rels_article_pdf_id_idx: index('search_results_rels_article_pdf_id_idx').on(
      columns.article_pdfID,
    ),
    search_results_rels_book_id_idx: index('search_results_rels_book_id_idx').on(columns.bookID),
    parentFk: foreignKey({
      columns: [columns['parent']],
      foreignColumns: [search_results.id],
      name: 'search_results_rels_parent_fk',
    }).onDelete('cascade'),
    videoIdFk: foreignKey({
      columns: [columns['videoID']],
      foreignColumns: [video.id],
      name: 'search_results_rels_video_fk',
    }).onDelete('cascade'),
    article_webIdFk: foreignKey({
      columns: [columns['article_webID']],
      foreignColumns: [article_web.id],
      name: 'search_results_rels_article_web_fk',
    }).onDelete('cascade'),
    article_pdfIdFk: foreignKey({
      columns: [columns['article_pdfID']],
      foreignColumns: [article_pdf.id],
      name: 'search_results_rels_article_pdf_fk',
    }).onDelete('cascade'),
    bookIdFk: foreignKey({
      columns: [columns['bookID']],
      foreignColumns: [book.id],
      name: 'search_results_rels_book_fk',
    }).onDelete('cascade'),
  }),
)

export const payload_locked_documents = pgTable(
  'payload_locked_documents',
  {
    id: uuid('id').defaultRandom().primaryKey(),
    globalSlug: varchar('global_slug'),
    updatedAt: timestamp('updated_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    payload_locked_documents_global_slug_idx: index('payload_locked_documents_global_slug_idx').on(
      columns.globalSlug,
    ),
    payload_locked_documents_updated_at_idx: index('payload_locked_documents_updated_at_idx').on(
      columns.updatedAt,
    ),
    payload_locked_documents_created_at_idx: index('payload_locked_documents_created_at_idx').on(
      columns.createdAt,
    ),
  }),
)

export const payload_locked_documents_rels = pgTable(
  'payload_locked_documents_rels',
  {
    id: serial('id').primaryKey(),
    order: integer('order'),
    parent: uuid('parent_id').notNull(),
    path: varchar('path').notNull(),
    usersID: varchar('users_id'),
    pricesID: uuid('prices_id'),
    productsID: uuid('products_id'),
    subscriptionsID: uuid('subscriptions_id'),
    mediaID: uuid('media_id'),
    taxonomyID: varchar('taxonomy_id'),
    article_pdfID: uuid('article_pdf_id'),
    article_webID: uuid('article_web_id'),
    bookID: uuid('book_id'),
    videoID: uuid('video_id'),
    permissionID: varchar('permission_id'),
    'search-resultsID': uuid('search_results_id'),
  },
  (columns) => ({
    order: index('payload_locked_documents_rels_order_idx').on(columns.order),
    parentIdx: index('payload_locked_documents_rels_parent_idx').on(columns.parent),
    pathIdx: index('payload_locked_documents_rels_path_idx').on(columns.path),
    payload_locked_documents_rels_users_id_idx: index(
      'payload_locked_documents_rels_users_id_idx',
    ).on(columns.usersID),
    payload_locked_documents_rels_prices_id_idx: index(
      'payload_locked_documents_rels_prices_id_idx',
    ).on(columns.pricesID),
    payload_locked_documents_rels_products_id_idx: index(
      'payload_locked_documents_rels_products_id_idx',
    ).on(columns.productsID),
    payload_locked_documents_rels_subscriptions_id_idx: index(
      'payload_locked_documents_rels_subscriptions_id_idx',
    ).on(columns.subscriptionsID),
    payload_locked_documents_rels_media_id_idx: index(
      'payload_locked_documents_rels_media_id_idx',
    ).on(columns.mediaID),
    payload_locked_documents_rels_taxonomy_id_idx: index(
      'payload_locked_documents_rels_taxonomy_id_idx',
    ).on(columns.taxonomyID),
    payload_locked_documents_rels_article_pdf_id_idx: index(
      'payload_locked_documents_rels_article_pdf_id_idx',
    ).on(columns.article_pdfID),
    payload_locked_documents_rels_article_web_id_idx: index(
      'payload_locked_documents_rels_article_web_id_idx',
    ).on(columns.article_webID),
    payload_locked_documents_rels_book_id_idx: index(
      'payload_locked_documents_rels_book_id_idx',
    ).on(columns.bookID),
    payload_locked_documents_rels_video_id_idx: index(
      'payload_locked_documents_rels_video_id_idx',
    ).on(columns.videoID),
    payload_locked_documents_rels_permission_id_idx: index(
      'payload_locked_documents_rels_permission_id_idx',
    ).on(columns.permissionID),
    payload_locked_documents_rels_search_results_id_idx: index(
      'payload_locked_documents_rels_search_results_id_idx',
    ).on(columns['search-resultsID']),
    parentFk: foreignKey({
      columns: [columns['parent']],
      foreignColumns: [payload_locked_documents.id],
      name: 'payload_locked_documents_rels_parent_fk',
    }).onDelete('cascade'),
    usersIdFk: foreignKey({
      columns: [columns['usersID']],
      foreignColumns: [users.id],
      name: 'payload_locked_documents_rels_users_fk',
    }).onDelete('cascade'),
    pricesIdFk: foreignKey({
      columns: [columns['pricesID']],
      foreignColumns: [prices.id],
      name: 'payload_locked_documents_rels_prices_fk',
    }).onDelete('cascade'),
    productsIdFk: foreignKey({
      columns: [columns['productsID']],
      foreignColumns: [products.id],
      name: 'payload_locked_documents_rels_products_fk',
    }).onDelete('cascade'),
    subscriptionsIdFk: foreignKey({
      columns: [columns['subscriptionsID']],
      foreignColumns: [subscriptions.id],
      name: 'payload_locked_documents_rels_subscriptions_fk',
    }).onDelete('cascade'),
    mediaIdFk: foreignKey({
      columns: [columns['mediaID']],
      foreignColumns: [media.id],
      name: 'payload_locked_documents_rels_media_fk',
    }).onDelete('cascade'),
    taxonomyIdFk: foreignKey({
      columns: [columns['taxonomyID']],
      foreignColumns: [taxonomy.id],
      name: 'payload_locked_documents_rels_taxonomy_fk',
    }).onDelete('cascade'),
    article_pdfIdFk: foreignKey({
      columns: [columns['article_pdfID']],
      foreignColumns: [article_pdf.id],
      name: 'payload_locked_documents_rels_article_pdf_fk',
    }).onDelete('cascade'),
    article_webIdFk: foreignKey({
      columns: [columns['article_webID']],
      foreignColumns: [article_web.id],
      name: 'payload_locked_documents_rels_article_web_fk',
    }).onDelete('cascade'),
    bookIdFk: foreignKey({
      columns: [columns['bookID']],
      foreignColumns: [book.id],
      name: 'payload_locked_documents_rels_book_fk',
    }).onDelete('cascade'),
    videoIdFk: foreignKey({
      columns: [columns['videoID']],
      foreignColumns: [video.id],
      name: 'payload_locked_documents_rels_video_fk',
    }).onDelete('cascade'),
    permissionIdFk: foreignKey({
      columns: [columns['permissionID']],
      foreignColumns: [permission.id],
      name: 'payload_locked_documents_rels_permission_fk',
    }).onDelete('cascade'),
    'search-resultsIdFk': foreignKey({
      columns: [columns['search-resultsID']],
      foreignColumns: [search_results.id],
      name: 'payload_locked_documents_rels_search_results_fk',
    }).onDelete('cascade'),
  }),
)

export const payload_preferences = pgTable(
  'payload_preferences',
  {
    id: uuid('id').defaultRandom().primaryKey(),
    key: varchar('key'),
    value: jsonb('value'),
    updatedAt: timestamp('updated_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    payload_preferences_key_idx: index('payload_preferences_key_idx').on(columns.key),
    payload_preferences_updated_at_idx: index('payload_preferences_updated_at_idx').on(
      columns.updatedAt,
    ),
    payload_preferences_created_at_idx: index('payload_preferences_created_at_idx').on(
      columns.createdAt,
    ),
  }),
)

export const payload_preferences_rels = pgTable(
  'payload_preferences_rels',
  {
    id: serial('id').primaryKey(),
    order: integer('order'),
    parent: uuid('parent_id').notNull(),
    path: varchar('path').notNull(),
    usersID: varchar('users_id'),
  },
  (columns) => ({
    order: index('payload_preferences_rels_order_idx').on(columns.order),
    parentIdx: index('payload_preferences_rels_parent_idx').on(columns.parent),
    pathIdx: index('payload_preferences_rels_path_idx').on(columns.path),
    payload_preferences_rels_users_id_idx: index('payload_preferences_rels_users_id_idx').on(
      columns.usersID,
    ),
    parentFk: foreignKey({
      columns: [columns['parent']],
      foreignColumns: [payload_preferences.id],
      name: 'payload_preferences_rels_parent_fk',
    }).onDelete('cascade'),
    usersIdFk: foreignKey({
      columns: [columns['usersID']],
      foreignColumns: [users.id],
      name: 'payload_preferences_rels_users_fk',
    }).onDelete('cascade'),
  }),
)

export const payload_migrations = pgTable(
  'payload_migrations',
  {
    id: uuid('id').defaultRandom().primaryKey(),
    name: varchar('name'),
    batch: numeric('batch'),
    updatedAt: timestamp('updated_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
    createdAt: timestamp('created_at', { mode: 'string', withTimezone: true, precision: 3 })
      .defaultNow()
      .notNull(),
  },
  (columns) => ({
    payload_migrations_updated_at_idx: index('payload_migrations_updated_at_idx').on(
      columns.updatedAt,
    ),
    payload_migrations_created_at_idx: index('payload_migrations_created_at_idx').on(
      columns.createdAt,
    ),
  }),
)

export const relations_users_accounts = relations(users_accounts, ({ one }) => ({
  _parentID: one(users, {
    fields: [users_accounts._parentID],
    references: [users.id],
    relationName: 'accounts',
  }),
}))
export const relations_users_sessions = relations(users_sessions, ({ one }) => ({
  _parentID: one(users, {
    fields: [users_sessions._parentID],
    references: [users.id],
    relationName: 'sessions',
  }),
}))
export const relations_users_verification_tokens = relations(
  users_verification_tokens,
  ({ one }) => ({
    _parentID: one(users, {
      fields: [users_verification_tokens._parentID],
      references: [users.id],
      relationName: 'verificationTokens',
    }),
  }),
)
export const relations_users = relations(users, ({ many }) => ({
  accounts: many(users_accounts, {
    relationName: 'accounts',
  }),
  sessions: many(users_sessions, {
    relationName: 'sessions',
  }),
  verificationTokens: many(users_verification_tokens, {
    relationName: 'verificationTokens',
  }),
}))
export const relations_prices = relations(prices, () => ({}))
export const relations_products_images = relations(products_images, ({ one }) => ({
  _parentID: one(products, {
    fields: [products_images._parentID],
    references: [products.id],
    relationName: 'images',
  }),
}))
export const relations_products_features = relations(products_features, ({ one }) => ({
  _parentID: one(products, {
    fields: [products_features._parentID],
    references: [products.id],
    relationName: 'features',
  }),
}))
export const relations_products_rels = relations(products_rels, ({ one }) => ({
  parent: one(products, {
    fields: [products_rels.parent],
    references: [products.id],
    relationName: '_rels',
  }),
  pricesID: one(prices, {
    fields: [products_rels.pricesID],
    references: [prices.id],
    relationName: 'prices',
  }),
  permissionID: one(permission, {
    fields: [products_rels.permissionID],
    references: [permission.id],
    relationName: 'permission',
  }),
}))
export const relations_products = relations(products, ({ many }) => ({
  images: many(products_images, {
    relationName: 'images',
  }),
  features: many(products_features, {
    relationName: 'features',
  }),
  _rels: many(products_rels, {
    relationName: '_rels',
  }),
}))
export const relations_subscriptions = relations(subscriptions, ({ one }) => ({
  user: one(users, {
    fields: [subscriptions.user],
    references: [users.id],
    relationName: 'user',
  }),
  product: one(products, {
    fields: [subscriptions.product],
    references: [products.id],
    relationName: 'product',
  }),
}))
export const relations_media = relations(media, () => ({}))
export const relations_taxonomy = relations(taxonomy, ({ one }) => ({
  parent: one(taxonomy, {
    fields: [taxonomy.parent],
    references: [taxonomy.id],
    relationName: 'parent',
  }),
}))
export const relations_article_pdf_rels = relations(article_pdf_rels, ({ one }) => ({
  parent: one(article_pdf, {
    fields: [article_pdf_rels.parent],
    references: [article_pdf.id],
    relationName: '_rels',
  }),
  permissionID: one(permission, {
    fields: [article_pdf_rels.permissionID],
    references: [permission.id],
    relationName: 'permission',
  }),
  taxonomyID: one(taxonomy, {
    fields: [article_pdf_rels.taxonomyID],
    references: [taxonomy.id],
    relationName: 'taxonomy',
  }),
}))
export const relations_article_pdf = relations(article_pdf, ({ one, many }) => ({
  cover: one(media, {
    fields: [article_pdf.cover],
    references: [media.id],
    relationName: 'cover',
  }),
  _rels: many(article_pdf_rels, {
    relationName: '_rels',
  }),
}))
export const relations_article_web_rels = relations(article_web_rels, ({ one }) => ({
  parent: one(article_web, {
    fields: [article_web_rels.parent],
    references: [article_web.id],
    relationName: '_rels',
  }),
  permissionID: one(permission, {
    fields: [article_web_rels.permissionID],
    references: [permission.id],
    relationName: 'permission',
  }),
  taxonomyID: one(taxonomy, {
    fields: [article_web_rels.taxonomyID],
    references: [taxonomy.id],
    relationName: 'taxonomy',
  }),
}))
export const relations_article_web = relations(article_web, ({ one, many }) => ({
  cover: one(media, {
    fields: [article_web.cover],
    references: [media.id],
    relationName: 'cover',
  }),
  _rels: many(article_web_rels, {
    relationName: '_rels',
  }),
}))
export const relations_book_ediciones = relations(book_ediciones, ({ one }) => ({
  _parentID: one(book, {
    fields: [book_ediciones._parentID],
    references: [book.id],
    relationName: 'Ediciones',
  }),
}))
export const relations_book_rels = relations(book_rels, ({ one }) => ({
  parent: one(book, {
    fields: [book_rels.parent],
    references: [book.id],
    relationName: '_rels',
  }),
  taxonomyID: one(taxonomy, {
    fields: [book_rels.taxonomyID],
    references: [taxonomy.id],
    relationName: 'taxonomy',
  }),
}))
export const relations_book = relations(book, ({ one, many }) => ({
  cover: one(media, {
    fields: [book.cover],
    references: [media.id],
    relationName: 'cover',
  }),
  Ediciones: many(book_ediciones, {
    relationName: 'Ediciones',
  }),
  _rels: many(book_rels, {
    relationName: '_rels',
  }),
}))
export const relations_video_rels = relations(video_rels, ({ one }) => ({
  parent: one(video, {
    fields: [video_rels.parent],
    references: [video.id],
    relationName: '_rels',
  }),
  permissionID: one(permission, {
    fields: [video_rels.permissionID],
    references: [permission.id],
    relationName: 'permission',
  }),
}))
export const relations_video = relations(video, ({ many }) => ({
  _rels: many(video_rels, {
    relationName: '_rels',
  }),
}))
export const relations_permission = relations(permission, () => ({}))
export const relations_search_results_rels = relations(search_results_rels, ({ one }) => ({
  parent: one(search_results, {
    fields: [search_results_rels.parent],
    references: [search_results.id],
    relationName: '_rels',
  }),
  videoID: one(video, {
    fields: [search_results_rels.videoID],
    references: [video.id],
    relationName: 'video',
  }),
  article_webID: one(article_web, {
    fields: [search_results_rels.article_webID],
    references: [article_web.id],
    relationName: 'article_web',
  }),
  article_pdfID: one(article_pdf, {
    fields: [search_results_rels.article_pdfID],
    references: [article_pdf.id],
    relationName: 'article_pdf',
  }),
  bookID: one(book, {
    fields: [search_results_rels.bookID],
    references: [book.id],
    relationName: 'book',
  }),
}))
export const relations_search_results = relations(search_results, ({ many }) => ({
  _rels: many(search_results_rels, {
    relationName: '_rels',
  }),
}))
export const relations_payload_locked_documents_rels = relations(
  payload_locked_documents_rels,
  ({ one }) => ({
    parent: one(payload_locked_documents, {
      fields: [payload_locked_documents_rels.parent],
      references: [payload_locked_documents.id],
      relationName: '_rels',
    }),
    usersID: one(users, {
      fields: [payload_locked_documents_rels.usersID],
      references: [users.id],
      relationName: 'users',
    }),
    pricesID: one(prices, {
      fields: [payload_locked_documents_rels.pricesID],
      references: [prices.id],
      relationName: 'prices',
    }),
    productsID: one(products, {
      fields: [payload_locked_documents_rels.productsID],
      references: [products.id],
      relationName: 'products',
    }),
    subscriptionsID: one(subscriptions, {
      fields: [payload_locked_documents_rels.subscriptionsID],
      references: [subscriptions.id],
      relationName: 'subscriptions',
    }),
    mediaID: one(media, {
      fields: [payload_locked_documents_rels.mediaID],
      references: [media.id],
      relationName: 'media',
    }),
    taxonomyID: one(taxonomy, {
      fields: [payload_locked_documents_rels.taxonomyID],
      references: [taxonomy.id],
      relationName: 'taxonomy',
    }),
    article_pdfID: one(article_pdf, {
      fields: [payload_locked_documents_rels.article_pdfID],
      references: [article_pdf.id],
      relationName: 'article_pdf',
    }),
    article_webID: one(article_web, {
      fields: [payload_locked_documents_rels.article_webID],
      references: [article_web.id],
      relationName: 'article_web',
    }),
    bookID: one(book, {
      fields: [payload_locked_documents_rels.bookID],
      references: [book.id],
      relationName: 'book',
    }),
    videoID: one(video, {
      fields: [payload_locked_documents_rels.videoID],
      references: [video.id],
      relationName: 'video',
    }),
    permissionID: one(permission, {
      fields: [payload_locked_documents_rels.permissionID],
      references: [permission.id],
      relationName: 'permission',
    }),
    'search-resultsID': one(search_results, {
      fields: [payload_locked_documents_rels['search-resultsID']],
      references: [search_results.id],
      relationName: 'search-results',
    }),
  }),
)
export const relations_payload_locked_documents = relations(
  payload_locked_documents,
  ({ many }) => ({
    _rels: many(payload_locked_documents_rels, {
      relationName: '_rels',
    }),
  }),
)
export const relations_payload_preferences_rels = relations(
  payload_preferences_rels,
  ({ one }) => ({
    parent: one(payload_preferences, {
      fields: [payload_preferences_rels.parent],
      references: [payload_preferences.id],
      relationName: '_rels',
    }),
    usersID: one(users, {
      fields: [payload_preferences_rels.usersID],
      references: [users.id],
      relationName: 'users',
    }),
  }),
)
export const relations_payload_preferences = relations(payload_preferences, ({ many }) => ({
  _rels: many(payload_preferences_rels, {
    relationName: '_rels',
  }),
}))
export const relations_payload_migrations = relations(payload_migrations, () => ({}))

type DatabaseSchema = {
  enum_prices_type: typeof enum_prices_type
  enum_prices_interval: typeof enum_prices_interval
  enum_products_type: typeof enum_products_type
  enum_subscriptions_status: typeof enum_subscriptions_status
  enum_book_ediciones_variant: typeof enum_book_ediciones_variant
  enum_book_ediciones_language: typeof enum_book_ediciones_language
  users_accounts: typeof users_accounts
  users_sessions: typeof users_sessions
  users_verification_tokens: typeof users_verification_tokens
  users: typeof users
  prices: typeof prices
  products_images: typeof products_images
  products_features: typeof products_features
  products: typeof products
  products_rels: typeof products_rels
  subscriptions: typeof subscriptions
  media: typeof media
  taxonomy: typeof taxonomy
  article_pdf: typeof article_pdf
  article_pdf_rels: typeof article_pdf_rels
  article_web: typeof article_web
  article_web_rels: typeof article_web_rels
  book_ediciones: typeof book_ediciones
  book: typeof book
  book_rels: typeof book_rels
  video: typeof video
  video_rels: typeof video_rels
  permission: typeof permission
  search_results: typeof search_results
  search_results_rels: typeof search_results_rels
  payload_locked_documents: typeof payload_locked_documents
  payload_locked_documents_rels: typeof payload_locked_documents_rels
  payload_preferences: typeof payload_preferences
  payload_preferences_rels: typeof payload_preferences_rels
  payload_migrations: typeof payload_migrations
  relations_users_accounts: typeof relations_users_accounts
  relations_users_sessions: typeof relations_users_sessions
  relations_users_verification_tokens: typeof relations_users_verification_tokens
  relations_users: typeof relations_users
  relations_prices: typeof relations_prices
  relations_products_images: typeof relations_products_images
  relations_products_features: typeof relations_products_features
  relations_products_rels: typeof relations_products_rels
  relations_products: typeof relations_products
  relations_subscriptions: typeof relations_subscriptions
  relations_media: typeof relations_media
  relations_taxonomy: typeof relations_taxonomy
  relations_article_pdf_rels: typeof relations_article_pdf_rels
  relations_article_pdf: typeof relations_article_pdf
  relations_article_web_rels: typeof relations_article_web_rels
  relations_article_web: typeof relations_article_web
  relations_book_ediciones: typeof relations_book_ediciones
  relations_book_rels: typeof relations_book_rels
  relations_book: typeof relations_book
  relations_video_rels: typeof relations_video_rels
  relations_video: typeof relations_video
  relations_permission: typeof relations_permission
  relations_search_results_rels: typeof relations_search_results_rels
  relations_search_results: typeof relations_search_results
  relations_payload_locked_documents_rels: typeof relations_payload_locked_documents_rels
  relations_payload_locked_documents: typeof relations_payload_locked_documents
  relations_payload_preferences_rels: typeof relations_payload_preferences_rels
  relations_payload_preferences: typeof relations_payload_preferences
  relations_payload_migrations: typeof relations_payload_migrations
}

declare module '@payloadcms/db-postgres/types' {
  export interface GeneratedDatabaseSchema {
    schema: DatabaseSchema
  }
}
